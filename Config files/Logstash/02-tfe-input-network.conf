input {
 udp {
  port => 5963
  codec => plain { charset => "UTF-8" }
  type => "NetworkEvent"
 }
}

filter {
 if [type] == "NetworkEvent" {
  grok {
   break_on_match => false
   match => {
    message => "(?m)%{TIMESTAMP_ISO8601:sourceTimestamp} %{IPORHOST:hostPrivateIP} %{WORD:computerName}\\%{WORD:userName} %{WORD:agentId} %{WORD:eventType} - a: %{GREEDYDATA:packetLenght_b64} b: %{GREEDYDATA:sourceIP_b64} c: %{GREEDYDATA:sourcePort_b64} d: %{GREEDYDATA:destinationIP_b64} e: %{GREEDYDATA:destinationPort_b64}"
   }
  }
  ruby {
   code => '
	require "base64"
        require "openssl"
	   
	def Decrypt(encrypted_data, key, iv, cipher_type)
         encrypted_data.gsub!("-","+")
	 encrypted_data.gsub!("_","/")
	 encrypted_data = Base64.decode64(encrypted_data)
         encrypted_data = encrypted_data.ljust((encrypted_data.size / 16.0).ceil * 16, "\0")
	 aes = OpenSSL::Cipher::Cipher.new(cipher_type)
    	 aes.decrypt
         aes.key = key
         aes.iv = iv
         return aes.update(encrypted_data) + aes.final  
	end
        
   	event["packetLenght"] = Decrypt(event["packetLenght_b64"], "1uBu8ycVugDIJz61", "1uBu8ycVugDIJz61", "aes-128-cbc")
	event["sourceIP"] = Decrypt(event["sourceIP_b64"], "1uBu8ycVugDIJz61", "1uBu8ycVugDIJz61", "aes-128-cbc")
	event["sourcePort"] = Decrypt(event["sourcePort_b64"], "1uBu8ycVugDIJz61", "1uBu8ycVugDIJz61", "aes-128-cbc")
	event["destinationIP"] = Decrypt(event["destinationIP_b64"], "1uBu8ycVugDIJz61", "1uBu8ycVugDIJz61", "aes-128-cbc")
	event["destinationPort"] = Decrypt(event["destinationPort_b64"], "1uBu8ycVugDIJz61", "1uBu8ycVugDIJz61", "aes-128-cbc")
        '
  }
  mutate {
   remove_field => [ "packetLenght_b64" ]
   remove_field => [ "sourceIP_b64" ]
   remove_field => [ "sourcePort_b64" ]
   remove_field => [ "destinationIP_b64" ]
   remove_field => [ "destinationPort_b64" ]
  }
 }
}

output {
 if [type] == "NetworkEvent" {
  elasticsearch {
   index => "logstash-thefraudexplorer-network-%{+YYYY.MM.dd}"
   hosts => "localhost"
  }
 }	
}
